package ru.eaeconsult.icn.eaeIcnPlugin.filters;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.Statement;
import java.util.Iterator;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.servlet.http.HttpServletRequest;
import javax.sql.DataSource;

import com.ibm.ecm.extension.PluginResponseFilter;
import com.ibm.ecm.extension.PluginServiceCallbacks;
import com.ibm.json.java.JSONArray;
import com.ibm.json.java.JSONObject;

/**
 * Provides an abstract class that is extended to create a filter for responses
 * from a particular service. The response from the service is provided to the
 * filter in JSON format before it is returned to the web browser. The filter
 * can then modify that response, and the modified response is returned to the
 * web browser.
 */
public class GetDesktopRespFilter extends PluginResponseFilter {

	private static String DS_NAME = null;
	private static String DS_USER = null;
	private static String DS_PWD = null;

    private static final String PLUGIN_ID = "EAEicnPlugin";
    private static final String FEATURE_ID = "CommonSearch";

	/**
	 * Returns an array of the services that are extended by this filter.
	 * 
	 * @return A <code>String</code> array of names of the services. These are
	 *         the servlet paths or Struts action names.
	 */
	public String[] getFilteredServices() {
		return new String[] { "/getDesktop" };
	}

	/**
	 * Filters the response from the service.
	 * 
	 * @param serverType
	 *            A <code>String</code> that indicates the type of server that
	 *            is associated with the service. This value can be one or more
	 *            of the following values separated by commas:
	 *            <table border="1">
	 *            <tr>
	 *            <th>Server Type</th>
	 *            <th>Description</th>
	 *            </tr>
	 *            <tr>
	 *            <td><code>p8</code></td>
	 *            <td>IBM FileNet P8</td>
	 *            </tr>
	 *            <tr>
	 *            <td><code>cm</code></td>
	 *            <td>IBM Content Manager</td>
	 *            </tr>
	 *            <tr>
	 *            <td><code>od</code></td>
	 *            <td>IBM Content Manager OnDemand</td>
	 *            </tr>
	 *         	  <tr>
	 *         		<td><code>cmis</code></td>
	 *         		<td>Content Management Interoperability Services</td>
	 *         	  </tr>
	 *            <tr>
	 *            <td><code>common</code></td>
	 *            <td>For services that are not associated with a particular
	 *            server</td>
	 *            </tr>
	 *            </table>
	 * @param callbacks
	 *            An instance of the
	 *            <code>{@link PluginServiceCallbacks PluginServiceCallbacks}</code>
	 *            class that contains functions that can be used by the service.
	 *            These functions provide access to plug-in configuration and
	 *            content server APIs.
	 * @param request
	 *            An <code>HttpServletRequest</code> object that provides the
	 *            request. The service can access the invocation parameters from
	 *            the request.
	 * @param jsonResponse
	 *            The <code>JSONObject</code> object that is generated by the
	 *            service. Typically, this object is serialized and sent as the
	 *            response. The filter modifies this object to change the
	 *            response that is sent.
	 * @throws Exception
	 *             For exceptions that occur when the service is running.
	 *             Information about the exception is logged as part of the
	 *             client logging and an error response is automatically
	 *             generated and returned.
	 */
	public void filter(String serverType, PluginServiceCallbacks callbacks,
			HttpServletRequest request, JSONObject jsonResponse) throws Exception {
		String pluginConfString = callbacks.loadConfiguration();
		JSONObject pluginConfData = JSONObject.parse(pluginConfString);
        JSONObject allPluginSettingsJSON = null;
        JSONObject pluginSettings = null;
        if (jsonResponse.containsKey("pluginSettings")) {
            allPluginSettingsJSON = (JSONObject) jsonResponse.get("pluginSettings");
        } else {
            allPluginSettingsJSON = new JSONObject();
            jsonResponse.put("pluginSettings", allPluginSettingsJSON);
        }
        if (allPluginSettingsJSON.containsKey(PLUGIN_ID)) {
            pluginSettings = (JSONObject) allPluginSettingsJSON.get(PLUGIN_ID);
        } else {
            pluginSettings = new JSONObject();
            allPluginSettingsJSON.put(PLUGIN_ID, pluginSettings);
        }

        pluginSettings.put("pluginConfig", pluginConfData);

		String featureConfString = callbacks.loadFeatureConfiguration(FEATURE_ID);

		String searchTreeJSON = "";
		String searchViewsJSON = "";
		String exportConfigJSON = "";
		String commonSearchTemplate = "";
		Boolean searchOpen = false;
		Boolean useDataFilter = false;

		String desktopId=(String) jsonResponse.get("id");
		
		JSONArray desktopConfigsArray = (JSONArray) pluginConfData.get("desktopConfigsArray");
		for (int i=0; i<desktopConfigsArray.size(); i++) {
			JSONObject jsonRow=(JSONObject) desktopConfigsArray.get(i);
			if (((String)jsonRow.get("desktopId")).equalsIgnoreCase(desktopId)) {
				searchTreeJSON=(String) jsonRow.get("searchTreeJSON");
				searchViewsJSON=(String) jsonRow.get("searchViewsJSON");
				commonSearchTemplate=(String) jsonRow.get("commonSearchTemplate");
				Object so=jsonRow.get("searchOpen");
				if (so instanceof String) {
					searchOpen=(((String)so).equalsIgnoreCase("on")) ? true : false;
				}
				so=jsonRow.get("useDataFilter");
				if (so instanceof String) {
					useDataFilter=(((String)so).equalsIgnoreCase("on")) ? true : false;
				}
				break;
			}
		}

		DS_NAME = (String) pluginConfData.get("dataSourceName");
		DS_USER = (String) pluginConfData.get("dataSourceUser");
		DS_PWD = (String) pluginConfData.get("dataSourcePwd");

		//saveJson(jsonResponse, "c:\\Temp\\Z_Desktop.json");
		if (!searchTreeJSON.equals("")) {
			if (DS_NAME!=null && !DS_NAME.equals("") && !DS_USER.equals("") && !DS_PWD.equals("")) {
				FileInputStream is = new FileInputStream(searchTreeJSON);
				JSONObject json = JSONObject.parse(is);
				processNode((JSONObject)json.get("tree"), "tree");
				pluginSettings.put("searchTree", json);
			}
		}

		if (!searchViewsJSON.equals("")) {
			FileInputStream is = new FileInputStream(searchViewsJSON);
			JSONObject json = JSONObject.parse(is);
			pluginSettings.put("searchViews", json);
		}

		if (!exportConfigJSON.equals("")) {
			FileInputStream is = new FileInputStream(exportConfigJSON);
			JSONObject json = JSONObject.parse(is);
			pluginSettings.put("exportConfig", json);
		}
		
		pluginSettings.put("commonSearchTemplate", commonSearchTemplate);
		pluginSettings.put("searchOpen", searchOpen);
		pluginSettings.put("useDataFilter", useDataFilter);

		System.out.println("Desktop got!");
	}

	private static void processNode(JSONObject node, String parentName) {
		String fullPath=parentName+"/"+node.get("name");
		//System.out.println(fullPath);

		if (node.containsKey("sqlrow")) {
			JSONObject row=(JSONObject)node.get("sqlrow");
			String expr_id=(String) node.get("id");
			String expr_name=(String) node.get("name");
			String expr_search=(String) node.get("search");
			String val_id="", val_name="", val_search="", val_sql="";
			Iterator it = row.keySet().iterator();
			val_id=expr_id;
			val_name=expr_name;
			val_search=expr_search;
			while(it.hasNext()) {
				String key = (String)it.next();
				String replVal = (String) row.get(key);
				if (replVal!=null) {
					val_id=val_id.replaceAll("::"+key+"::", replVal);
					val_name=val_name.replaceAll("::"+key+"::", replVal);
					val_search=val_search.replaceAll("::"+key+"::", replVal);
				}
			}
			node.put("id", val_id);
			node.put("name", val_name);
			node.put("search", val_search);
		}

		if (node.containsKey("children")) {
			Object o = node.get("children");
			if (! (o instanceof JSONArray)) {
				JSONArray childrenJSON=new JSONArray();
				JSONObject chn= (JSONObject) node.get("children");
				if (chn.containsKey("sql")) {
					String sqlstmt=(String) chn.get("sql");

					if (node.containsKey("sqlrow")) {
						JSONObject row=(JSONObject)node.get("sqlrow");
						Iterator it = row.keySet().iterator();
						while(it.hasNext()) {
							String key = (String)it.next();
							sqlstmt=sqlstmt.replaceAll("::"+key+"::", (String) row.get(key));
						}
					}

					JSONArray sqlJSON =performDbRequest(sqlstmt);

					for (int i=0; i<sqlJSON.size(); i++) {
						JSONObject row=(JSONObject) sqlJSON.get(i);
						JSONObject newRow=new JSONObject();
						newRow.put("id", (String) chn.get("id"));
						newRow.put("name", (String) chn.get("name"));
						newRow.put("search", (String) chn.get("search"));
						newRow.put("sqlrow", row);
						if (chn.containsKey("viewset")) {
							newRow.put("viewset", (String) chn.get("viewset"));
						}
						if (chn.containsKey("children")) {
							try {
								Object cho=chn.get("children");
								if (cho instanceof JSONArray) {
									JSONArray chnJSON=JSONArray.parse(((JSONArray)cho).serialize());
									newRow.put("children", chnJSON);
								} else if (cho instanceof JSONObject) {
									JSONObject chnJSON=JSONObject.parse(((JSONObject)cho).serialize());
									newRow.put("children", chnJSON);
								}
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
						childrenJSON.add(newRow);
					}
				}
				node.put("children", childrenJSON);
			}
			JSONArray children = (JSONArray) node.get("children");
			for (int i=0; i<children.size(); i++) {
				JSONObject child = (JSONObject) children.get(i);
				if (node.containsKey("sqlrow")) {
					try {
						JSONObject newJSON=JSONObject.parse(((JSONObject)node.get("sqlrow")).serialize());
						//newJSON=(JSONObject) ((JSONObject)node.get("sqlrow")).clone();
						if (child.containsKey("sqlrow")) {
							JSONObject childJSON = (JSONObject)child.get("sqlrow");
							Iterator it=newJSON.keySet().iterator();
							while (it.hasNext()) {
								String key=(String) it.next();
								childJSON.put(key, newJSON.get(key));
							}
							child.put("sqlrow", childJSON);
						} else {
							child.put("sqlrow", newJSON);
						}
					} catch (Exception e) {
						e.printStackTrace();
					}

				}
				processNode(child, fullPath);
			}
		}
	}

	private static JSONArray performDbRequest(String sqlStmt) {
		JSONArray retVal=new JSONArray();
		Context ctx;
		DataSource ds;
		Connection con;
		String dbName = DS_NAME;
		String userName = DS_USER;
		String userPwd = DS_PWD;
		try {
			ctx = new InitialContext();
			ds = (DataSource) ctx.lookup(dbName);
			con = ds.getConnection(userName, userPwd);
			Statement stmt = con.createStatement();
			ResultSet rs = stmt.executeQuery(sqlStmt);
			ResultSetMetaData rsmd = rs.getMetaData();
			while (rs.next()) {
				int numColumns = rsmd.getColumnCount();
				JSONObject obj = new JSONObject();

				for (int i=1; i<numColumns+1; i++) {
					String column_name = rsmd.getColumnLabel(i);

					if(rsmd.getColumnType(i)==java.sql.Types.ARRAY){
						obj.put(column_name, rs.getArray(i));
					}
					else if(rsmd.getColumnType(i)==java.sql.Types.BIGINT){
						obj.put(column_name, rs.getInt(i));
					}
					else if(rsmd.getColumnType(i)==java.sql.Types.BOOLEAN){
						obj.put(column_name, rs.getBoolean(i));
					}
					else if(rsmd.getColumnType(i)==java.sql.Types.BLOB){
						obj.put(column_name, rs.getBlob(i));
					}
					else if(rsmd.getColumnType(i)==java.sql.Types.DOUBLE){
						obj.put(column_name, rs.getDouble(i)); 
					}
					else if(rsmd.getColumnType(i)==java.sql.Types.FLOAT){
						obj.put(column_name, rs.getFloat(i));
					}
					else if(rsmd.getColumnType(i)==java.sql.Types.INTEGER){
						obj.put(column_name, rs.getInt(i));
					}
					else if(rsmd.getColumnType(i)==java.sql.Types.NVARCHAR){
						obj.put(column_name, rs.getNString(i));
					}
					else if(rsmd.getColumnType(i)==java.sql.Types.VARCHAR){
						obj.put(column_name, rs.getString(i));
					}
					else if(rsmd.getColumnType(i)==java.sql.Types.TINYINT){
						obj.put(column_name, rs.getInt(i));
					}
					else if(rsmd.getColumnType(i)==java.sql.Types.SMALLINT){
						obj.put(column_name, rs.getInt(i));
					}
					else if(rsmd.getColumnType(i)==java.sql.Types.DATE){
						obj.put(column_name, rs.getDate(i));
					}
					else if(rsmd.getColumnType(i)==java.sql.Types.TIMESTAMP){
						obj.put(column_name, rs.getTimestamp(i));   
					}
					else{
						obj.put(column_name, rs.getObject(i));
					}
				}
				retVal.add(obj);
			}
			rs.close();
			con.close();
		} catch (Exception e) {
			e.printStackTrace();
		}

		return retVal;
	}

	private void saveJson(JSONObject jsonObject, String fileName) {
		File tmpJSON=new File(fileName);
		if (tmpJSON.exists()) {
			tmpJSON.delete();
		}
		try {
			FileOutputStream tmpos=new FileOutputStream(tmpJSON);
			jsonObject.serialize(tmpos);
			tmpos.flush();
			tmpos.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
